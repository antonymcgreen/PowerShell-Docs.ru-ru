---
description: PSReadLine предоставляет улучшенные возможности редактирования командной строки в консоли PowerShell.
Locale: en-US
ms.date: 11/23/2020
online version: https://docs.microsoft.com/powershell/module/psreadline/about/about_psreadline?view=powershell-7.2&WT.mc_id=ps-gethelp
schema: 2.0.0
title: О PSReadLine
ms.openlocfilehash: 4836abfec465ba7cdfb6800c1e60104fba19ce08
ms.sourcegitcommit: 560a9f3c3148acab4655e91e8b07745ab74d5d26
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/09/2020
ms.locfileid: "99601480"
---
# <a name="psreadline"></a>PSReadLine

## <a name="about_psreadline"></a>about_PSReadLine

## <a name="short-description"></a>Краткое описание

PSReadLine предоставляет улучшенные возможности редактирования командной строки в консоли PowerShell.

## <a name="long-description"></a>Полное описание

PSReadLine 2,2 предоставляет широкие возможности редактирования командной строки для консоли PowerShell. Консоль предоставляет следующие возможности:

- Цветовое выделение синтаксиса командной строки
- Визуальное обозначение синтаксических ошибок
- Более эффективный многострочный интерфейс (как редактирование, так и журнал)
- Настраиваемые сочетания клавиш
- Режимы работы cmd и Emacs
- Множество параметров конфигурации
- Завершение стиля bash (необязательно в режиме cmd, по умолчанию в режиме Emacs)
- Emacs: Янк/Kill-Ring
- Перемещение и уничтожение токена PowerShell на основе маркеров "Word"
- Прогнозирование IntelliSense

PSReadLine 2.2.0 добавил две новые функции прогнозной IntelliSense:

- Добавлен параметр **предиктионвиевстиле** , позволяющий выбрать новый объект `ListView` .
- Подключение PSReadLine к `CommandPrediction` API-интерфейсам, появившимся в PS 7,1, чтобы разрешить пользователю импортировать модуль прогнозирования, который может отображать предложения из пользовательского источника.

Для PSReadLine требуется PowerShell 3,0 или более поздней версии. PSReadLine работает с узлом консоли по умолчанию, Visual Studio Code и окном терминала. Он не работает в интегрированной среде сценариев PowerShell.

PSReadLine 2.2.0 поставляется с PowerShell 7,2 и поддерживается во всех поддерживаемых версиях PowerShell. Его можно установить из коллекция PowerShell.
Чтобы установить PSReadLine 2.2.0 в поддерживаемой версии PowerShell, выполните следующую команду.

```powershell
Install-Module -Name PSReadLine -AllowPrerelease
```

> [!NOTE]
> Начиная с PowerShell 7,0, PowerShell пропускает автоматическую загрузку PSReadLine в Windows при обнаружении программы чтения с экрана. В настоящее время PSReadLine плохо работает с программами чтения с экрана. Визуализация и форматирование по умолчанию для PowerShell 7,0 в Windows работают правильно. При необходимости модуль можно загрузить вручную.

## <a name="predictive-intellisense"></a>Прогнозирование IntelliSense

Прогнозная IntelliSense является дополнением к концепции заполнения нажатием клавиши TAB, которая помогает пользователю успешно завершать команды. Она позволяет пользователям обнаруживать, изменять и выполнять полные команды на основе прогнозов, находящихся в истории пользователя, и дополнительных подключаемых модулей для конкретных доменов.

### <a name="enable-predictive-intellisense"></a>Включение прогнозного IntelliSense

По умолчанию прогнозная технология IntelliSense отключена. Чтобы включить прогнозы, просто выполните следующую команду:

```powershell
Set-PSReadLineOption -PredictionSource History
```

Параметр **предиктионсаурце** также может принимать подключаемые модули для конкретных требований, связанных с доменами, и пользовательскими требованиями.

Чтобы отключить прогнозную IntelliSense, просто выполните команду:

```powershell
Set-PSReadLineOption -PredictionSource None
```

В классе **[Microsoft. PowerShell. псконсолереадлине]** доступны следующие функции.

## <a name="basic-editing-functions"></a>Базовые функции редактирования

### <a name="abort"></a>Прервать

Прервать текущее действие, например добавочный поиск по журналу.

- Emacs: `<Ctrl+g>`

### <a name="acceptandgetnext"></a>акцептанджетнекст

Попытка выполнить текущий вход. Если его можно выполнить (например, Акцептлине), то следует отозвать следующий элемент из журнала при следующем вызове метода ReadLine.

- Emacs: `<Ctrl+o>`

### <a name="acceptline"></a>акцептлине

Попытка выполнить текущий вход. Если текущий ввод неполон (например, отсутствует закрывающая круглая скобка, квадратная скобка или кавычка, запрос продолжения отображается на следующей строке, а PSReadLine ожидает ввода ключей для изменения текущих входных данных.

- Процессор `<Enter>`
- Emacs: `<Enter>`
- Режим вставки в VI: `<Enter>`

### <a name="addline"></a>аддлине

Запрос продолжения отображается на следующей строке, а PSReadLine ожидает ввода ключей для изменения текущих входных данных. Это полезно для ввода многострочных входных данных в виде одной команды, даже если одна строка завершается самим вводом.

- Процессор `<Shift+Enter>`
- Emacs: `<Shift+Enter>`
- Режим вставки в VI: `<Shift+Enter>`
- Режим команд VI: `<Shift+Enter>`

### <a name="backwarddeletechar"></a>бакквардделетечар

Удалить символ перед курсором.

- Cmd: `<Backspace>` , `<Ctrl+h>`
- Emacs: `<Backspace>` , `<Ctrl+Backspace>` , `<Ctrl+h>`
- Режим вставки в VI: `<Backspace>`
- Режим команд VI: `<X>` , `<d,h>`

### <a name="backwarddeleteline"></a>бакквардделетелине

Like Бакквардкилллине — удаляет текст с точки до начала строки, но не помещает удаленный текст в инструкцию KILL-Ring.

- Процессор `<Ctrl+Home>`
- Режим вставки в VI: `<Ctrl+u>` , `<Ctrl+Home>`
- Режим команд VI: `<Ctrl+u>` , `<Ctrl+Home>` , `<d,0>`

### <a name="backwarddeleteword"></a>бакквардделетеворд

Удаляет предыдущее слово.

- Режим команд VI: `<Ctrl+w>` , `<d,b>`

### <a name="backwardkillline"></a>бакквардкилллине

Очистить входные данные от начала ввода до курсора. Очистка текста помещается в буфер Kill.

- Emacs: `<Ctrl+u>` , `<Ctrl+x,Backspace>`

### <a name="backwardkillword"></a>бакквардкиллворд

Очистить ввод от начала текущего слова до курсора. Если курсор находится между словами, входные данные очищаются от начала предыдущего слова до курсора. Очистка текста помещается в буфер Kill.

- Cmd: `<Ctrl+Backspace>` , `<Ctrl+w>`
- Emacs: `<Alt+Backspace>` , `<Escape,Backspace>`
- Режим вставки в VI: `<Ctrl+Backspace>`
- Режим команд VI: `<Ctrl+Backspace>`

### <a name="cancelline"></a>канцеллине

Отмена текущих входных данных с выходом на экран, но возврат к узлу, чтобы снова выполнить оценку запроса.

- Режим вставки в VI: `<Ctrl+c>`
- Режим команд VI: `<Ctrl+c>`

### <a name="copy"></a>Копировать

Копировать выбранный регион в буфер обмена системы. Если регион не выбран, скопируйте всю строку.

- Процессор `<Ctrl+C>`

### <a name="copyorcancelline"></a>копйорканцеллине

Если выбран текст, скопируйте в буфер обмена, в противном случае отмените строку.

- Процессор `<Ctrl+c>`
- Emacs: `<Ctrl+c>`

### <a name="cut"></a>Вырезать

Удалить выбранный регион, поместив удаленный текст в системный буфер обмена.

- Процессор `<Ctrl+x>`

### <a name="deletechar"></a>делетечар

Удалите символ под курсором.

- Процессор `<Delete>`
- Emacs: `<Delete>`
- Режим вставки в VI: `<Delete>`
- Режим команд VI: `<Delete>` , `<x>` , `<d,l>` , `<d,Spacebar>`

### <a name="deletecharorexit"></a>делетечарорексит

Удалите символ под курсором или, если строка пуста, завершите процесс.

- Emacs: `<Ctrl+d>`

### <a name="deleteendofbuffer"></a>делетиндофбуффер

Удаляет до конца многострочного буфера.

- Режим команд VI: `<d,G>`

### <a name="deleteendofword"></a>делетиндофворд

Удалить до конца слова.

- Режим команд VI: `<d,e>`

### <a name="deleteline"></a>Сбой deleteline

Удаляет текущую логическую строку многострочного буфера, включая отмену.

- Режим команд VI: `<d,d>` , `<d,_>`

### <a name="deletepreviouslines"></a>делетепревиауслинес

Удаляет предыдущие запрошенные логические строки и текущую логическую строку в многострочном буфере.

- Режим команд VI: `<d,k>`

### <a name="deleterelativelines"></a>делетерелативелинес

Удаляет с начала буфера до текущей логической строки в многострочном буфере.

Как и в большинстве команд VI, `<d,g,g>` команду можно добавить в начало с числовым аргументом, который указывает абсолютный номер строки, который вместе с текущим номером строки позволяет удалить диапазон строк.
Если не указано, числовой аргумент по умолчанию равен 1, что означает первую логическую строку в многострочном буфере.

Фактическое число строк, удаляемых из многострочного, вычисляются как разница между текущим логическим номером и заданным числовым аргументом, который, таким образом, может быть отрицательным. Поэтому это _Относительная_ часть имени метода.

- Режим команд VI: `<d,g,g>`

### <a name="deletenextlines"></a>делетенекстлинес

Удаляет текущую логическую строку и следующие запрошенные логические строки в многострочном буфере.

- Режим команд VI: `<d,j>`

### <a name="deletelinetofirstchar"></a>делетелинетофирстчар

Удаляет из первого непустого символа текущей логической строки в многострочном буфере.

- Режим команд VI: `<d,^>`

### <a name="deletetoend"></a>делететоенд

Удалить до конца строки.

- Режим команд VI: `<D>` , `<d,$>`

### <a name="deleteword"></a>DeleteWord

Удалить следующее слово.

- Режим команд VI: `<d,w>`

### <a name="forwarddeleteline"></a>форвардделетелине

Как и Форвардкилллине — удаляет текст с точки до конца строки, но не помещает удаленный текст в инструкцию KILL-Ring.

- Процессор `<Ctrl+End>`
- Режим вставки в VI: `<Ctrl+End>`
- Режим команд VI: `<Ctrl+End>`

### <a name="insertlineabove"></a>инсертлинеабове

Новая пустая строка создается над текущей строкой, независимо от того, где находится курсор на текущей строке. Курсор переместится в начало новой строки.

- Процессор `<Ctrl+Enter>`

### <a name="insertlinebelow"></a>инсертлинебелов

Новая пустая строка создается под текущей строкой независимо от того, где находится курсор на текущей строке. Курсор переместится в начало новой строки.

- Процессор `<Shift+Ctrl+Enter>`

### <a name="invertcase"></a>инверткасе

Инвертировать регистр текущего символа и перейти к следующему.

- Режим команд VI: `<~>`

### <a name="killline"></a>килллине

Очистить входные данные от курсора до конца входных данных. Очистка текста помещается в буфер Kill.

- Emacs: `<Ctrl+k>`

### <a name="killregion"></a>киллрегион

Удалить текст между курсором и меткой.

- Функция не привязана.

### <a name="killword"></a>киллворд

Очистить ввод от курсора до конца текущего слова. Если курсор находится между словами, входные данные очищаются от курсора до конца следующего слова. Очистка текста помещается в буфер Kill.

- Cmd: `<Alt+d>` , `<Ctrl+Delete>`
- Emacs: `<Alt+d>` , `<Escape,d>`
- Режим вставки в VI: `<Ctrl+Delete>`
- Режим команд VI: `<Ctrl+Delete>`

### <a name="paste"></a>Вставить

Вставка текста из буфера обмена системы.

- Cmd: `<Ctrl+v>` , `<Shift+Insert>`
- Режим вставки в VI: `<Ctrl+v>`
- Режим команд VI: `<Ctrl+v>`

> [!IMPORTANT]
> При использовании функции **вставки** все содержимое буфера буфера обмена вставляется во входной буфер PSReadLine. Затем входной буфер передается средству синтаксического анализа PowerShell. Вход, вставленный с помощью консольного приложения, щелкните **правой кнопкой мыши** метод вставки, скопированный во входной буфер по одному символу за раз. Входной буфер передается средству синтаксического анализа при копировании символа новой строки. Поэтому входные данные анализируются по одной строке за раз. Различие между методами вставки приводит к различному поведению при выполнении.

### <a name="pasteafter"></a>пастеафтер

Вставьте буфер обмена после курсора, переместив курсор в конец вставленного текста.

- Режим команд VI: `<p>`

### <a name="pastebefore"></a>пастебефоре

Вставьте буфер обмена перед курсором, переместив курсор в конец вставленного текста.

- Режим команд VI: `<P>`

### <a name="prependandaccept"></a>препендандакцепт

Добавьте в начало "#" и примите строку.

- Режим команд VI: `<#>`

### <a name="redo"></a>Повторить

Отмена отмены.

- Процессор `<Ctrl+y>`
- Режим вставки в VI: `<Ctrl+y>`
- Режим команд VI: `<Ctrl+y>`

### <a name="repeatlastcommand"></a>репеатласткомманд

Повторите Последнее изменение текста.

- Режим команд VI: `<.>`

### <a name="revertline"></a>ревертлине

Меняет все входные данные на текущие входные данные.

- Процессор `<Escape>`
- Emacs: `<Alt+r>` , `<Escape,r>`

### <a name="shellbackwardkillword"></a>шеллбакквардкиллворд

Очистить ввод от начала текущего слова до курсора. Если курсор находится между словами, входные данные очищаются от начала предыдущего слова до курсора. Очистка текста помещается в буфер Kill.

Функция не привязана.

### <a name="shellkillword"></a>шеллкиллворд

Очистить ввод от курсора до конца текущего слова. Если курсор находится между словами, входные данные очищаются от курсора до конца следующего слова. Очистка текста помещается в буфер Kill.

Функция не привязана.

### <a name="swapcharacters"></a>свапчарактерс

Поменять местами текущий и тот же символ.

- Emacs: `<Ctrl+t>`
- Режим вставки в VI: `<Ctrl+t>`
- Режим команд VI: `<Ctrl+t>`

### <a name="undo"></a>Отменить

Отмена предыдущего изменения.

- Процессор `<Ctrl+z>`
- Emacs: `<Ctrl+_>` , `<Ctrl+x,Ctrl+u>`
- Режим вставки в VI: `<Ctrl+z>`
- Режим команд VI: `<Ctrl+z>` , `<u>`

### <a name="undoall"></a>ундоалл

Отмена всех предыдущих изменений для строки.

- Режим команд VI: `<U>`

### <a name="unixwordrubout"></a>униксвордрубаут

Очистить ввод от начала текущего слова до курсора. Если курсор находится между словами, входные данные очищаются от начала предыдущего слова до курсора. Очистка текста помещается в буфер Kill.

- Emacs: `<Ctrl+w>`

### <a name="validateandacceptline"></a>валидатеандакцептлине

Попытка выполнить текущий вход. Если текущий ввод неполон (например, отсутствует закрывающая круглая скобка, квадратная скобка или кавычка, запрос продолжения отображается на следующей строке, а PSReadLine ожидает ввода ключей для изменения текущих входных данных.

- Emacs: `<Ctrl+m>`

### <a name="viacceptline"></a>виакцептлине

Примите строку и переключитесь в режим вставки.

- Режим команд VI: `<Enter>`

### <a name="viacceptlineorexit"></a>виакцептлинеорексит

Как и Делетечарорексит в режиме Emacs, но принимает строку вместо удаления символа.

- Режим вставки в VI: `<Ctrl+d>`
- Режим команд VI: `<Ctrl+d>`

### <a name="viappendline"></a>виаппендлине

Новая строка вставляется под текущей строкой.

- Режим команд VI: `<o>`

### <a name="vibackwarddeleteglob"></a>вибакквардделетеглоб

Удаляет предыдущее слово, используя только пробелы в качестве разделителя слов.

- Режим команд VI: `<d,B>`

### <a name="vibackwardglob"></a>вибакквардглоб

Перемещает курсор назад к началу предыдущего слова, используя только пробелы в качестве разделителей.

- Режим команд VI: `<B>`

### <a name="videletebrace"></a>виделетебраце

Найдите парную фигурную скобку, круглую скобку или квадратную скобку и удалите все содержимое внутри, включая фигурную скобку.

- Режим команд VI: `<d,%>`

### <a name="videleteendofglob"></a>виделетиндофглоб

Удалить до конца слова.

- Режим команд VI: `<d,E>`

### <a name="videleteglob"></a>виделетеглоб

Удалите следующий стандартная маска (слово, разделенное пробелами).

- Режим команд VI: `<d,W>`

### <a name="videletetobeforechar"></a>виделететобефоречар

Удаляет до заданного символа.

- Режим команд VI: `<d,t>`

### <a name="videletetobeforecharbackward"></a>виделететобефоречарбакквард

Удаляет до заданного символа.

- Режим команд VI: `<d,T>`

### <a name="videletetochar"></a>виделететочар

Удаляет до заданного символа.

- Режим команд VI: `<d,f>`

### <a name="videletetocharbackward"></a>виделететочарбакквард

Удаляет обратную сторону до заданного символа.

- Режим команд VI: `<d,F>`

### <a name="viinsertatbegining"></a>виинсертатбегининг

Переключитесь в режим вставки и поместите курсор в начало строки.

- Режим команд VI: `<I>`

### <a name="viinsertatend"></a>виинсертатенд

Переключитесь в режим вставки и поместите курсор в конец строки.

- Режим команд VI: `<A>`

### <a name="viinsertline"></a>виинсертлине

Новая строка вставляется над текущей строкой.

- Режим команд VI: `<O>`

### <a name="viinsertwithappend"></a>виинсертвисаппенд

Добавление из текущей позицией строки.

- Режим команд VI: `<a>`

### <a name="viinsertwithdelete"></a>виинсертвисделете

Удалите текущий символ и переключитесь в режим вставки.

- Режим команд VI: `<s>`

### <a name="vijoinlines"></a>вижоинлинес

Объединяет текущую строку и следующую строку.

- Режим команд VI: `<J>`

### <a name="vireplaceline"></a>виреплацелине

Очистить всю командную строку.

- Режим команд VI: `<S>` , `<c,c>`

### <a name="vireplacetobeforechar"></a>виреплацетобефоречар

Заменяет заданный символ.

- Режим команд VI: `<c,t>`

### <a name="vireplacetobeforecharbackward"></a>виреплацетобефоречарбакквард

Заменяет заданный символ.

- Режим команд VI: `<c,T>`

### <a name="vireplacetochar"></a>виреплацеточар

Удаляет до заданного символа.

- Режим команд VI: `<c,f>`

### <a name="vireplacetocharbackward"></a>виреплацеточарбакквард

Заменяет заданный символ.

- Режим команд VI: `<c,F>`

### <a name="viyankbeginningofline"></a>вийанкбегиннингофлине

Янк от начала буфера до курсора.

- Режим команд VI: `<y,0>`

### <a name="viyankendofglob"></a>вийанкендофглоб

Янк от курсора до конца слова.

- Режим команд VI: `<y,E>`

### <a name="viyankendofword"></a>вийанкендофворд

Янк от курсора до конца слова.

- Режим команд VI: `<y,e>`

### <a name="viyankleft"></a>вийанклефт

Янк символы слева от курсора.

- Режим команд VI: `<y,h>`

### <a name="viyankline"></a>вийанклине

Янк весь буфер.

- Режим команд VI: `<y,y>`

### <a name="viyanknextglob"></a>вийанкнекстглоб

Янк от курсора до начала следующего слова.

- Режим команд VI: `<y,W>`

### <a name="viyanknextword"></a>вийанкнекстворд

Янк слова после курсора.

- Режим команд VI: `<y,w>`

### <a name="viyankpercent"></a>вийанкперцент

Янк в парную фигурную скобку.

- Режим команд VI: `<y,%>`

### <a name="viyankpreviousglob"></a>вийанкпревиаусглоб

Янк от начала слов до курсора.

- Режим команд VI: `<y,B>`

### <a name="viyankpreviousword"></a>вийанкпревиаусворд

Янк слова перед курсором.

- Режим команд VI: `<y,b>`

### <a name="viyankright"></a>вийанкригхт

Янк символы в положении и справа от курсора.

- Режим команд VI: `<y,l>` , `<y,Spacebar>`

### <a name="viyanktoendofline"></a>вийанктоендофлине

Янк от курсора до конца буфера.

- Режим команд VI: `<y,$>`

### <a name="viyanktofirstchar"></a>вийанктофирстчар

Янк от первого символа, отличного от пробела, к курсору.

- Режим команд VI: `<y,^>`

### <a name="yank"></a>янк

Добавление последнего недавнего текста во входные данные.

- Emacs: `<Ctrl+y>`

### <a name="yanklastarg"></a>янкластарг

Янк последний аргумент из предыдущей строки журнала. С аргументом при первом вызове он ведет себя так же, как Янкнсарг. Если вызывается несколько раз, вместо этого выполняется итерация по журналу, а аргумент устанавливает направление (отрицательно меняет направление на противоположное).

- Процессор `<Alt+.>`
- Emacs: `<Alt+.>` , `<Alt+_>` , `<Escape,.>` , `<Escape,_>`

### <a name="yankntharg"></a>янкнсарг

Янк первый аргумент (после команды) из предыдущей строки журнала.
При использовании аргумента Янк аргумент n (начиная с 0), если аргумент является отрицательным, начните с последнего аргумента.

- Emacs: `<Ctrl+Alt+y>` , `<Escape,Ctrl+y>`

### <a name="yankpop"></a>янкпоп

Если предыдущая операция была Янк или Янкпоп, замените ранее янкед текст следующим уничтоженным текстом из Kill-Ring.

- Emacs: `<Alt+y>` , `<Escape,y>`

## <a name="cursor-movement-functions"></a>Функции перемещения курсора

### <a name="backwardchar"></a>бакквардчар

Переместить курсор на один символ влево. Это может переместить курсор к предыдущей строке многострочного ввода.

- Процессор `<LeftArrow>`
- Emacs: `<LeftArrow>` , `<Ctrl+b>`

### <a name="backwardword"></a>бакквардворд

Перемещение курсора назад к началу текущего слова или между словами, с начала предыдущего слова. Границы слов определяются с помощью настраиваемого набора символов.

- Процессор `<Ctrl+LeftArrow>`
- Emacs: `<Alt+b>` , `<Escape,b>`
- Режим вставки в VI: `<Ctrl+LeftArrow>`
- Режим команд VI: `<Ctrl+LeftArrow>`

### <a name="beginningofline"></a>бегиннингофлине

Если входные данные имеют несколько строк, переместитесь в начало текущей строки или, если они уже находятся в начале строки, перейдите к началу входного элемента. Если входные данные имеют одну строку, переходите к началу входных данных.

- Процессор `<Home>`
- Emacs: `<Home>` , `<Ctrl+a>`
- Режим вставки в VI: `<Home>`
- Режим команд VI: `<Home>`

### <a name="endofline"></a>ендофлине

Если входные данные имеют несколько строк, переместитесь в конец текущей строки или, если они уже находятся в конце строки, перейдите к концу входных данных. Если входные данные имеют одну строку, переходите к концу входных данных.

- Процессор `<End>`
- Emacs: `<End>` , `<Ctrl+e>`
- Режим вставки в VI: `<End>`

### <a name="forwardchar"></a>форвардчар

Переместить курсор на один символ вправо. Это может переместить курсор на следующую строку многострочного ввода.

- Процессор `<RightArrow>`
- Emacs: `<RightArrow>` , `<Ctrl+f>`

### <a name="forwardword"></a>форвардворд

Переместить курсор вперед к концу текущего слова или между словами, до конца следующего слова. Границы слов определяются с помощью настраиваемого набора символов.

- Emacs: `<Alt+f>` , `<Escape,f>`

### <a name="gotobrace"></a>GotoBrace

Перейдите к парной фигурной скобке, круглой скобке или квадратной скобке.

- Процессор `<Ctrl+]>`
- Режим вставки в VI: `<Ctrl+]>`
- Режим команд VI: `<Ctrl+]>`

### <a name="gotocolumn"></a>готоколумн

Переход к столбцу, указанному аргументом arg.

- Режим команд VI: `<|>`

### <a name="gotofirstnonblankofline"></a>готофирстнонбланкофлине

Переместить курсор к первому непустому символу в строке.

- Режим команд VI: `<^>` , `<_>`

### <a name="movetoendofline"></a>моветоендофлине

Переместить курсор в конец входных данных.

- Режим команд VI: `<End>` , `<$>`

### <a name="nextline"></a>некстлине

Переместить курсор на следующую строку.

- Функция не привязана.

### <a name="nextword"></a>некстворд

Переместить курсор вперед к началу следующего слова. Границы слов определяются с помощью настраиваемого набора символов.

- Процессор `<Ctrl+RightArrow>`
- Режим вставки в VI: `<Ctrl+RightArrow>`
- Режим команд VI: `<Ctrl+RightArrow>`

### <a name="nextwordend"></a>некстворденд

Переместить курсор вперед к концу текущего слова или между словами, до конца следующего слова. Границы слов определяются с помощью настраиваемого набора символов.

- Режим команд VI: `<e>`

### <a name="previousline"></a>превиауслине

Переместить курсор на предыдущую строку.

- Функция не привязана.

### <a name="shellbackwardword"></a>шеллбакквардворд

Перемещение курсора назад к началу текущего слова или между словами, с начала предыдущего слова. Границы слов определяются токенами PowerShell.

- Функция не привязана.

### <a name="shellforwardword"></a>шеллфорвардворд

Переместить курсор вперед к началу следующего слова. Границы слов определяются токенами PowerShell.

- Функция не привязана.

### <a name="shellnextword"></a>шеллнекстворд

Переместить курсор вперед к концу текущего слова или между словами, до конца следующего слова. Границы слов определяются токенами PowerShell.

- Функция не привязана.

### <a name="vibackwardchar"></a>вибакквардчар

Переместить курсор на один символ влево в режиме редактирования VI. Это может переместить курсор к предыдущей строке многострочного ввода.

- Режим вставки в VI: `<LeftArrow>`
- Режим команд VI: `<LeftArrow>` , `<Backspace>` , `<h>`

### <a name="vibackwardword"></a>вибакквардворд

Перемещение курсора назад к началу текущего слова или между словами, с начала предыдущего слова. Границы слов определяются с помощью настраиваемого набора символов.

- Режим команд VI: `<b>`

### <a name="viforwardchar"></a>вифорвардчар

Переместить курсор на один символ вправо в режиме редактирования VI. Это может переместить курсор на следующую строку многострочного ввода.

- Режим вставки в VI: `<RightArrow>`
- Режим команд VI: `<RightArrow>` , `<Spacebar>` , `<l>`

### <a name="viendofglob"></a>виендофглоб

Перемещает курсор в конец слова, используя только пробелы в качестве разделителей.

- Режим команд VI: `<E>`

### <a name="viendofpreviousglob"></a>виендофпревиаусглоб

Переход к концу предыдущего слова с использованием только пробелов в качестве разделителя слов.

- Функция не привязана.

### <a name="vigotobrace"></a>виготобраце

Аналогичен Готобраце, но является символом, а не основан на токене.

- Режим команд VI: `<%>`

### <a name="vinextglob"></a>винекстглоб

Переход к следующему слову с использованием только пробелов в качестве разделителя слов.

- Режим команд VI: `<W>`

### <a name="vinextword"></a>винекстворд

Переместить курсор вперед к началу следующего слова. Границы слов определяются с помощью настраиваемого набора символов.

- Режим команд VI: `<w>`

## <a name="history-functions"></a>Функции журнала

### <a name="beginningofhistory"></a>бегиннингофхистори

Перейти к первому элементу в журнале.

- Emacs: `<Alt+<>`

### <a name="clearhistory"></a>клеархистори

Очищает журнал в PSReadLine. Это не влияет на журнал PowerShell.

- Процессор `<Alt+F7>`

### <a name="endofhistory"></a>ендофхистори

Переход к последнему элементу (текущему входному объекту) в журнале.

- Emacs: `<Alt+>>`

### <a name="forwardsearchhistory"></a>форвардсеарчхистори

Выполните добавочный поиск по журналу.

- Процессор `<Ctrl+s>`
- Emacs: `<Ctrl+s>`

### <a name="historysearchbackward"></a>хисторисеарчбакквард

Замените текущие входные данные элементом "Previous" из журнала PSReadLine, который соответствует символам между началом и входом и курсором.

- Процессор `<F8>`

### <a name="historysearchforward"></a>хисторисеарчфорвард

Замените текущие входные данные элементом "Next" из журнала PSReadLine, который соответствует символам между началом и входом и курсором.

- Процессор `<Shift+F8>`

### <a name="nexthistory"></a>некссистори

Замените текущие входные данные на элемент "Next" из журнала PSReadLine.

- Процессор `<DownArrow>`
- Emacs: `<DownArrow>` , `<Ctrl+n>`
- Режим вставки в VI: `<DownArrow>`
- Режим команд VI: `<DownArrow>` , `<j>` , `<+>`

### <a name="previoushistory"></a>превиаушистори

Замените текущие входные данные элементом "Previous" из журнала PSReadLine.

- Процессор `<UpArrow>`
- Emacs: `<UpArrow>` , `<Ctrl+p>`
- Режим вставки в VI: `<UpArrow>`
- Режим команд VI: `<UpArrow>` , `<k>` , `<->`

### <a name="reversesearchhistory"></a>реверсесеарчхистори

Выполните добавочный поиск по журналу.

- Процессор `<Ctrl+r>`
- Emacs: `<Ctrl+r>`

### <a name="visearchhistorybackward"></a>висеарчхисторибакквард

Запрашивает строку поиска и инициирует поиск по запросу Акцептлине.

- Режим вставки в VI: `<Ctrl+r>`
- Режим команд VI: `</>` , `<Ctrl+r>`

## <a name="completion-functions"></a>Функции завершения

### <a name="complete"></a>Завершить

Попытка выполнить завершение в тексте, окружающем курсор. Если существует несколько возможных завершений, для завершения используется самый длинный ненеоднозначный префикс. При попытке выполнить наибольшее неоднозначное Завершение отображается список возможных завершений.

- Emacs: `<Tab>`

### <a name="menucomplete"></a>менукомплете

Попытка выполнить завершение в тексте, окружающем курсор. Если существует несколько возможных завершений, для завершения используется самый длинный ненеоднозначный префикс. При попытке выполнить наибольшее неоднозначное Завершение отображается список возможных завершений.

- Cmd: `<Ctrl+@>` , `<Ctrl+Spacebar>`
- Emacs: `<Ctrl+Spacebar>`

### <a name="possiblecompletions"></a>поссиблекомплетионс

Отображение списка возможных завершений.

- Emacs: `<Alt+=>`
- Режим вставки в VI: `<Ctrl+Spacebar>`
- Режим команд VI: `<Ctrl+Spacebar>`

### <a name="tabcompletenext"></a>табкомплетенекст

Попытайтесь завершить текст, окружающий курсор, с помощью следующего доступного завершения.

- Процессор `<Tab>`
- Режим команд VI: `<Tab>`

### <a name="tabcompleteprevious"></a>табкомплетепревиаус

Попытайтесь завершить текст, окружающий курсор, с предыдущим доступным завершением.

- Процессор `<Shift+Tab>`
- Режим команд VI: `<Shift+Tab>`

### <a name="vitabcompletenext"></a>витабкомплетенекст

При необходимости завершает текущую группу редактирования и вызывает Табкомплетенекст.

- Режим вставки в VI: `<Tab>`

### <a name="vitabcompleteprevious"></a>витабкомплетепревиаус

При необходимости завершает текущую группу редактирования и вызывает Табкомплетепревиаус.

- Режим вставки в VI: `<Shift+Tab>`

## <a name="miscellaneous-functions"></a>Прочие функции

### <a name="acceptnextsuggestionword"></a>акцептнекстсугжестионворд

Принять следующее слово встроенного или выбранного предложения.

- Функция не привязана.

### <a name="acceptsuggestion"></a>акцептсугжестион

Принять текущее встроенное или выбранное предложение.

- Функция не привязана.

### <a name="capturescreen"></a>каптурескрин

Запуск интерактивной записи экрана — стрелки вверх и вниз выбор строк, ввод копирует выделенный текст в буфер обмена в виде текста и HTML.

- Функция не привязана.

### <a name="clearscreen"></a>клеарскрин

Очистить экран и нарисовать текущую строку в верхней части экрана.

- Процессор `<Ctrl+l>`
- Emacs: `<Ctrl+l>`
- Режим вставки в VI: `<Ctrl+l>`
- Режим команд VI: `<Ctrl+l>`

### <a name="digitargument"></a>дигитаргумент

Начните новый аргумент цифры для передачи другим функциям.

- Cmd: `<Alt+0>` , `<Alt+1>` , `<Alt+2>` , `<Alt+3>` , `<Alt+4>` , `<Alt+5>` , `<Alt+6>` , `<Alt+7>` , `<Alt+8>` , `<Alt+9>` , `<Alt+->`
- Emacs: `<Alt+0>` , `<Alt+1>` , `<Alt+2>` , `<Alt+3>` , `<Alt+4>` , `<Alt+5>` , `<Alt+6>` , `<Alt+7>` , `<Alt+8>` , `<Alt+9>` , `<Alt+->`
- Режим команд VI: `<0>` , `<1>` , `<2>` , `<3>` , `<4>` , `<5>` , `<6>` , `<7>` , `<8>` , `<9>`

### <a name="invokeprompt"></a>инвокепромпт

Стирает текущий запрос и вызывает функцию Prompt для повторного вывода запроса. Полезен для обработчиков пользовательских ключей, изменяющих состояние, например для изменения текущего каталога.

- Функция не привязана.

### <a name="scrolldisplaydown"></a>скроллдисплайдовн

Прокрутите экран вниз на один экран.

- Процессор `<PageDown>`
- Emacs: `<PageDown>`

### <a name="scrolldisplaydownline"></a>скроллдисплайдовнлине

Прокрутите экран вниз на одну строку.

- Процессор `<Ctrl+PageDown>`
- Emacs: `<Ctrl+PageDown>`

### <a name="scrolldisplaytocursor"></a>скроллдисплайтокурсор

Прокрутить экран до курсора.

- Emacs: `<Ctrl+End>`

### <a name="scrolldisplaytop"></a>скроллдисплайтоп

Прокрутите экран до верха.

- Emacs: `<Ctrl+Home>`

### <a name="scrolldisplayup"></a>скроллдисплайуп

Прокрутите экран вверх на один экран.

- Процессор `<PageUp>`
- Emacs: `<PageUp>`

### <a name="scrolldisplayupline"></a>скроллдисплайуплине

Прокрутите экран вверх на одну строку.

- Процессор `<Ctrl+PageUp>`
- Emacs: `<Ctrl+PageUp>`

### <a name="selfinsert"></a>селфинсерт

Вставьте ключ.

- Функция не привязана.

### <a name="showkeybindings"></a>шовкэйбиндингс

Отображение всех связанных ключей.

- Процессор `<Ctrl+Alt+?>`
- Emacs: `<Ctrl+Alt+?>`
- Режим вставки в VI: `<Ctrl+Alt+?>`

### <a name="vicommandmode"></a>викоммандмоде

Переключите текущий режим работы с Vi-Insert на VI-Command.

- Режим вставки в VI: `<Escape>`

### <a name="vidigitargumentinchord"></a>видигитаргументинчорд

Начните новый числовой аргумент, чтобы передать его другим функциям в одной из сочетаний VI.

- Функция не привязана.

### <a name="vieditvisually"></a>виедитвисуалли

Измените командную строку в текстовом редакторе, заданном $env: EDITOR или $env: VISUAL.

- Emacs: `<Ctrl+x,Ctrl+e>`
- Режим команд VI: `<v>`

### <a name="viexit"></a>виексит

Завершает работу оболочки.

- Функция не привязана.

### <a name="viinsertmode"></a>виинсертмоде

Переключитесь в режим вставки.

- Режим команд VI: `<i>`

### <a name="whatiskey"></a>вхатискэй

Прочитайте ключ и расскажите, к чему привязан ключ.

- Процессор `<Alt+?>`
- Emacs: `<Alt+?>`

## <a name="selection-functions"></a>Функции выбора

### <a name="exchangepointandmark"></a>ексчанжепоинтандмарк

Курсор помещается в позицию метки, а метка перемещается в положение курсора.

- Emacs: `<Ctrl+x,Ctrl+x>`

### <a name="selectall"></a>SelectAll

Выделите всю строку.

- Процессор `<Ctrl+a>`

### <a name="selectbackwardchar"></a>селектбакквардчар

Настройка текущего выделения для включения предыдущего символа.

- Процессор `<Shift+LeftArrow>`
- Emacs: `<Shift+LeftArrow>`

### <a name="selectbackwardsline"></a>селектбакквардслине

Изменить текущее выделение, чтобы включить его от курсора до начала строки.

- Процессор `<Shift+Home>`
- Emacs: `<Shift+Home>`

### <a name="selectbackwardword"></a>селектбакквардворд

Настройка текущего выделения для включения предыдущего слова.

- Процессор `<Shift+Ctrl+LeftArrow>`
- Emacs: `<Alt+B>`

### <a name="selectforwardchar"></a>селектфорвардчар

Измените текущее выделение, чтобы включить следующий символ.

- Процессор `<Shift+RightArrow>`
- Emacs: `<Shift+RightArrow>`

### <a name="selectforwardword"></a>селектфорвардворд

Измените текущее выделение, чтобы включить следующее слово с помощью Форвардворд.

- Emacs: `<Alt+F>`

### <a name="selectline"></a>селектлине

Настройка текущего выделения для включения курсора в конец строки.

- Процессор `<Shift+End>`
- Emacs: `<Shift+End>`

### <a name="selectnextword"></a>селектнекстворд

Настройка текущего выделения для включения следующего слова.

- Процессор `<Shift+Ctrl+RightArrow>`

### <a name="selectshellbackwardword"></a>селектшеллбакквардворд

Измените текущее выделение, чтобы включить предыдущее слово с помощью Шеллбакквардворд.

- Функция не привязана.

### <a name="selectshellforwardword"></a>селектшеллфорвардворд

Измените текущее выделение, чтобы включить следующее слово с помощью Шеллфорвардворд.

- Функция не привязана.

### <a name="selectshellnextword"></a>селектшеллнекстворд

Измените текущее выделение, чтобы включить следующее слово с помощью Шеллнекстворд.

- Функция не привязана.

### <a name="setmark"></a>сетмарк

Пометка текущего положения курсора для использования в последующей команде редактирования.

- Emacs: `<Ctrl+@>`

## <a name="predictive-intellisense-functions"></a>Функции прогнозной IntelliSense

> [!NOTE]
> Для использования этих функций необходимо включить прогнозную технологию IntelliSense.

### <a name="acceptnextwordsuggestion"></a>акцептнекствордсугжестион

Принимает следующее слово встроенного предложения из прогнозной IntelliSense.
Эту функцию можно привязать с помощью <kbd>клавиши CTRL</kbd> + <kbd>F</kbd> , выполнив следующую команду.

```powershell
Set-PSReadLineKeyHandler -Chord "Ctrl+f" -Function ForwardWord
```

### <a name="acceptsuggestion"></a>акцептсугжестион

Принимает текущее встроенное предложение от прогнозной IntelliSense, нажимая клавишу <kbd>RightArrow</kbd> , когда курсор находится в конце текущей строки.

## <a name="search-functions"></a>Функции поиска

### <a name="charactersearch"></a>чарактерсеарч

Чтение символа и поиск вперед для следующего вхождения этого символа.
Если указан аргумент, то для n-го вхождения выполните поиск вперед (или назад, если отрицательное).

- Процессор `<F3>`
- Emacs: `<Ctrl+]>`
- Режим вставки в VI: `<F3>`
- Режим команд VI: `<F3>`

### <a name="charactersearchbackward"></a>чарактерсеарчбакквард

Чтение символа и поиск следующего вхождения этого символа в обратном направлении. Если аргумент указан, поиск в n-й последовательности осуществляется назад (или вперед, если отрицательное).

- Процессор `<Shift+F3>`
- Emacs: `<Ctrl+Alt+]>`
- Режим вставки в VI: `<Shift+F3>`
- Режим команд VI: `<Shift+F3>`

### <a name="repeatlastcharsearch"></a>репеатластчарсеарч

Повторите поиск последнего записанного символа.

- Режим команд VI: `<;>`

### <a name="repeatlastcharsearchbackwards"></a>репеатластчарсеарчбакквардс

Повторите поиск последнего записанного символа, но в обратном направлении.

- Режим команд VI: `<,>`

### <a name="repeatsearch"></a>репеатсеарч

Повторите последний поиск в том же направлении, что и раньше.

- Режим команд VI: `<n>`

### <a name="repeatsearchbackward"></a>репеатсеарчбакквард

Повторите последний поиск в том же направлении, что и раньше.

- Режим команд VI: `<N>`

### <a name="searchchar"></a>сеарччар

Прочитать следующий символ, затем найти его, перейти вперед, а затем отследить символ. Это относится к функциональным возможностям.

- Режим команд VI: `<f>`

### <a name="searchcharbackward"></a>сеарччарбакквард

Прочитать следующий символ, а затем найти его, вернуться назад, а затем отследить символ. Это относится к функциональным возможностям.

- Режим команд VI: `<F>`

### <a name="searchcharbackwardwithbackoff"></a>сеарччарбакквардвисбаккофф

Прочитать следующий символ, а затем найти его, вернуться назад, а затем отследить символ. Это относится к функциональным возможностям.

- Режим команд VI: `<T>`

### <a name="searchcharwithbackoff"></a>сеарччарвисбаккофф

Прочитать следующий символ, затем найти его, перейти вперед, а затем отследить символ. Это относится к функциональным возможностям.

- Режим команд VI: `<t>`

### <a name="searchforward"></a>сеарчфорвард

Запрашивает строку поиска и инициирует поиск по запросу Акцептлине.

- Режим вставки в VI: `<Ctrl+s>`
- Режим команд VI: `<?>` , `<Ctrl+s>`

## <a name="custom-key-bindings"></a>Пользовательские привязки клавиш

PSReadLine поддерживает пользовательские привязки клавиш с помощью командлета `Set-PSReadLineKeyHandler` . Большинство пользовательских привязок вызывают одну из приведенных выше функций, например

```powershell
Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
```

Можно привязать ScriptBlock к ключу. Блок ScriptBlock может выполнять практически все необходимые действия. Ниже приведены некоторые полезные примеры.

- Изменение командной строки
- Открытие нового окна (например, Справка)
- Изменение каталогов без изменения командной строки

Блок ScriptBlock получает два аргумента:

- `$key` — Объект **[консолекэйинфо]** , который является ключом, запускающим пользовательскую привязку. Если один и тот же блок сценария привязан к нескольким ключам и необходимо выполнять различные действия в зависимости от ключа, можно проверить $key. Многие пользовательские привязки игнорируют этот аргумент.

- `$arg` — Произвольный аргумент. Чаще всего это будет целочисленный аргумент, который пользователь передает из ключевых привязок Дигитаргумент. Если привязка не принимает аргументы, целесообразно проигнорировать этот аргумент.

Рассмотрим пример, который добавляет в журнал командную строку, не выполняя ее. Это полезно, если вы забыли сделать что-то, но не хотите повторно вводить уже введенную командную строку.

```powershell
$parameters = @{
    Key = 'Alt+w'
    BriefDescription = 'SaveInHistory'
    LongDescription = 'Save current line in history but do not execute'
    ScriptBlock = {
      param($key, $arg)   # The arguments are ignored in this example

      # GetBufferState gives us the command line (with the cursor position)
      $line = $null
      $cursor = $null
      [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line,
        [ref]$cursor)

      # AddToHistory saves the line in history, but does not execute it.
      [Microsoft.PowerShell.PSConsoleReadLine]::AddToHistory($line)

      # RevertLine is like pressing Escape.
      [Microsoft.PowerShell.PSConsoleReadLine]::RevertLine()
  }
}
Set-PSReadLineKeyHandler @parameters
```

В файле, `SamplePSReadLineProfile.ps1` который устанавливается в папку модуля PSReadLine, можно увидеть много других примеров.

Большинство ключевых привязок используют некоторые вспомогательные функции для редактирования командной строки.
Эти API-интерфейсы описаны в следующем разделе.

## <a name="custom-key-binding-support-apis"></a>API поддержки пользовательского сочетания клавиш

Следующие функции являются открытыми в Microsoft. PowerShell. Псконсолереадлине, но не могут быть напрямую привязаны к ключу. Большинство из них удобно использовать в пользовательских привязках клавиш.

```csharp
void AddToHistory(string command)
```

Добавьте командную строку в журнал, не выполняя ее.

```csharp
void ClearKillRing()
```

Снимите флажок Kill-Ring.  Это в основном используется для тестирования.

```csharp
void Delete(int start, int length)
```

Удалить символы длины из Start.  Эта операция поддерживает операцию отмены и повтора.

```csharp
void Ding()
```

Выполните действие DING, основанное на предпочтениях пользователей.

```csharp
void GetBufferState([ref] string input, [ref] int cursor)
void GetBufferState([ref] Ast ast, [ref] Token[] tokens,
  [ref] ParseError[] parseErrors, [ref] int cursor)
```

Эти две функции извлекают полезную информацию о текущем состоянии входного буфера.  Первый из них чаще всего используется в простых случаях.  Второй используется, если привязка делает что-то более сложное с AST.

```csharp
IEnumerable[Microsoft.PowerShell.KeyHandler]
  GetKeyHandlers(bool includeBound, bool includeUnbound)

IEnumerable[Microsoft.PowerShell.KeyHandler]
  GetKeyHandlers(string[] Chord)
```

Эти две функции используются `Get-PSReadLineKeyHandler` . Первый используется для получения всех привязок клавиш. Второй используется для получения конкретных привязок клавиш.

```csharp
Microsoft.PowerShell.PSConsoleReadLineOptions GetOptions()
```

Эта функция используется Get-PSReadLineOption и, возможно, не слишком полезна в пользовательской привязке ключа.

```csharp
void GetSelectionState([ref] int start, [ref] int length)
```

Если в командной строке ничего не выбрано, значение-1 будет возвращено как в начале, так и в длине. Если в командной строке имеется выделенный фрагмент, то начинается и длина выбора возвращается.

```csharp
void Insert(char c)
void Insert(string s)
```

Вставка символа или строки в курсоре.  Эта операция поддерживает операцию отмены и повтора.

```csharp
string ReadLine(runspace remoteRunspace,
  System.Management.Automation.EngineIntrinsics engineIntrinsics)
```

Это Главная точка входа для PSReadLine. Она не поддерживает рекурсию, поэтому она не полезна в пользовательской привязке ключа.

```csharp
void RemoveKeyHandler(string[] key)
```

Эта функция используется Remove-PSReadLineKeyHandler и, возможно, не слишком полезна в пользовательской привязке ключа.

```csharp
void Replace(int start, int length, string replacement)
```

Замените некоторые входные данные. Эта операция поддерживает операцию отмены и повтора. Это предпочтительнее удаление с последующим вставкой, так как оно обрабатывается как одно действие для отмены.

```csharp
void SetCursorPosition(int cursor)
```

Переместить курсор к заданному смещению. Перемещение курсора не ведется для отмены.

```csharp
void SetOptions(Microsoft.PowerShell.SetPSReadLineOption options)
```

Эта функция является вспомогательным методом, используемым командлетом Set-PSReadLineOption, но может быть полезен для пользовательской привязки ключа, которая хочет временно изменить параметр.

```csharp
bool TryGetArgAsInt(System.Object arg, [ref] int numericArg,
  int defaultNumericArg)
```

Этот вспомогательный метод используется для пользовательских привязок, которые учитывают Дигитаргумент. Обычный вызов выглядит следующим образом:

```powershell
[int]$numericArg = 0
[Microsoft.PowerShell.PSConsoleReadLine]::TryGetArgAsInt($arg,
  [ref]$numericArg, 1)
```

## <a name="notes"></a>Примечания

### <a name="command-history"></a>Журнал команд

PSReadLine поддерживает файл журнала, содержащий все команды и данные, введенные из командной строки. Это может быть конфиденциальные данные, включая пароли. Например, при использовании `ConvertTo-SecureString` командлета пароль заносится в файл журнала в виде обычного текста. Файлы журнала — это файл с именем `$($host.Name)_history.txt` . В системах Windows файл журнала хранится в файле `$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine` . В системах, отличных от Windows, файлы журнала хранятся в `$env:XDG_DATA_HOME/powershell/PSReadLine` или `$env:HOME/.local/share/powershell/PSReadLine` .

### <a name="feedback--contributing-to-psreadline"></a>Обратная связь & участие в PSReadLine

[PSReadLine на GitHub](https://github.com/PowerShell/PSReadLine)

Вы можете отправить запрос на вытягивание или отправить отзыв на страницу GitHub.

## <a name="see-also"></a>См. также:

На PSReadLine сильно влияют библиотеки GNU [ReadLine](https://tiswww.case.edu/php/chet/readline/rltop.html) .
